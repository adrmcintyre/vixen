;; Adapted from the softfloat library by John R Hauser.
;; See https://github.com/ucb-bar/berkeley-softfloat-3

; Requires f16_internal.asm

.f16_div
{
    ; working registers
    alias r5 rem
    alias r6 a_exp
    alias r7 b_exp
    alias r8 index
    alias r9 recip
    alias r10 deriv_lo
    alias r11 deriv_hi

    mov tmp, #.f16_sign_mask
    mov z_sign, a
    eor z_sign, b
    and z_sign, tmp         ; calc result sign
    bic a, #.f16_sign_mask  ; a=abs(a)
    bic b, #.f16_sign_mask  ; b=abs(b)

    mov tmp, #.f16_exp_mask ; exponent mask
    mov a_exp, a
    mov b_exp, b
    bic a, tmp              ; isolate fractions
    bic b, tmp
    lsr a_exp, #10          ; extract exponents
    lsr b_exp, #10

    mov tmp, #0x1f          ; inf/nan indicator

    cmp a_exp, tmp          ; isInfOrNan(a) ?
    prne
    bra .a_finite

    and a, a
    prne
    bra .f16_return_nan     ; isNan(a) => NaN
    cmp b_exp, tmp
    preq
    bra .f16_return_nan     ; isInfOrNan(b) => NaN
    bra .f16_return_inf     ;          else => inf

.a_finite
    cmp b_exp, tmp          ; isInfOrNan(b) ?
    prne
    bra .b_finite
    and b, b
    prne
    bra .f16_return_nan     ; isNan(b) => NaN
    bra .f16_return_zero    ; else     => 0

.b_finite
    and b_exp, b_exp        ; isSubOrZero(b) ?
    prne
    bra .b_normal
    and b, b                ; isZero(b) ?
    prne
    bra .b_subnormal
    orr a_exp, a
    prne
    bra .f16_return_inf     ; !isZero(a) => inf
    bra .f16_return_nan     ;       else => NaN

.b_subnormal
    clz tmp, b              ; normalise b
    sub tmp, #5             ; (shift highest 1 bit up to bit 10)
    lsl b, tmp
    mov b_exp, #1
    sub b_exp, tmp

.b_normal
    and a_exp, a_exp        ; isSubOrZero(a) ?
    prne
    bra .a_normal

    and a, a                ; !isZero(a)
    preq
    bra .f16_return_zero

    clz tmp, a              ; normalise a - max(tmp) = 15
    sub tmp, #5             ;               max(tmp) = 10
    lsl a, tmp
    mov a_exp, #1
    sub a_exp, tmp          ;               min(a_exp) = -9

    ; a and b have both been normalised at this point

.a_normal
    mov z_exp, a_exp        ; compute result exponent with bias
    sub z_exp, b_exp        ;               max(b_exp) = 30, so min(z_exp) = -9-30 = -39
    add z_exp, #14          ;               min(z_exp) = -39+14 = -25

    orr a, #bit 10          ; set implicit ones
    orr b, #bit 10

    cmp a, b                ; a < b ?
    prhs                
    bra .no_double_a

    sub z_exp, #1           ; double a to ensure result >= 1    min(z_exp) = -25-1 = -26
    lsl a, #1

.no_double_a
    lsl a, #4               ; pad a with 4 trailing 0s for accurate rounding

    mov index, b            ; compute table index
    lsr index, #6
    mov tmp, #0xf
    and index, tmp
    lsl index, #2

    mov tmp, #hi(.f16_recip_approx_data)
    add tmp, #lo(.f16_recip_approx_data)
    add index, tmp
    ldw recip, [index]              ; look up recip=1/x
    ldw deriv_lo, [index, #2]       ; and deriv=1/x^2

    mov tmp, #0x3f                  ; scale deriv by low bits of a (the error)
    and tmp, b
    mov deriv_hi, deriv_lo
    mul deriv_lo, tmp
    muh deriv_hi, tmp

    lsl deriv_hi, #6                ; align prior to subtraction
    lsr deriv_lo, #10
    orr deriv_hi, deriv_lo

    sub recip, deriv_hi             ; adjust recip by scaled deriv

    mov z, a                        ; initial quotient
    muh z, recip

    ;; Calculate: u16 rem = (a << 10) - z * b;
    ;;
    ;; NOTE - the remainder will be 16 bits, but the intermediates reach 32,
    ;; though since we truncate the result, it doesn't actually matter if the
    ;; intermediate terms overflow.
    ;; 
    ;; TODO optimisation
    ;;      lsl a, #10
    ;;      mov rem, a
    ;;  then later when recomputing remainder, we just need
    ;;      mov rem, a
    mov rem, a                      ; compute remainder
    lsl rem, #10
    mov tmp, z
    mul tmp, b
    sub rem, tmp                    ; rem = a - z*b

    muh rem, recip
    lsr rem, #10                    ; remainder indicates our quotient is low,
    add z, rem                      ; so boost proportionally (and vice versa)

    add z, #1
    mov tmp, #7
    tst z, tmp
    prne
    bra .f16_round_pack

;;  bic z, #bit 0                   ; redundant as bits 2..0 are known to be 000 here

    mov rem, a                      ; recompute remainder
    lsl rem, #10
    mov tmp, z
    mul tmp, a
    sub rem, tmp                    ; rem = a - z'*b

    prpl                            ; if rem < 0 z must be too large
    bra .adjust_elseif

    sub z, #2                       ; so adjust down
    bra .f16_round_pack

.adjust_elseif
    prne                            ; elseif rem > 0, z is too small
    orr z, #bit 0                   ; so adjust up
    bra .f16_round_pack

; These constants can be generated by the following code.
; (See https://stackoverflow.com/a/32640889):
;
;   for(int i = 0; i < 16; i++) {
;        double x0 = 1.0+i/16.0;       // left endpoint of interval
;        double x1 = 1.0+(i+1)/16.0;   // right endpoint of interval
;        double f0 = 1.0 / x0;
;        double f1 = 1.0 / x1;
;        double df = f0 - f1;
;        double sl = df * 16.0;        // slope across interval
;        double mp = (x0 + x1) / 2.0;  // midpoint of interval
;        double fm = 1.0 / mp;
;        double ic = fm + df / 2.0;    // intercept at start of interval
;
;        printf("dw %04x %04x\n",
;           (int)(ic * 65536.0 - 0.9999),
;           (int)(sl * 65536.0 + 0.9999));
;   }
;
; This yields the 1.15 fixed point equivalent of the following,
; taking x = 1 + i/16
;
;            1       1                        1       slope
;   slope = --- - --------  ;  intercept = -------- + -----
;            x    x + 1/16                 x + 1/32     2
;
; Where `intercept` starts with the value at the midpoint, and is then shifted up
; the slope to the endpoint. This is instead of evaluating the endpoint directly
; because when the error term is applied based on the slope we want to minimise
; the maximum error either side.
;
; When multiplied by the remaining bits unused in looking up the initial estimate
; `slope` provides the error correction to be subtracted. Note that the `slope`
; constants are scaled by a factor of 16 to makes the most of the 16 bits of
; available precision.

.f16_recip_approx_data
    dw 0xFFC4, 0xF0F1
    dw 0xF0BE, 0xD62C
    dw 0xE363, 0xBFA1
    dw 0xD76F, 0xAC77
    dw 0xCCAD, 0x9C0A
    dw 0xC2F0, 0x8DDB
    dw 0xBA16, 0x8185
    dw 0xB201, 0x76BA
    dw 0xAA97, 0x6D3B
    dw 0xA3C6, 0x64D4
    dw 0x9D7A, 0x5D5C
    dw 0x97A6, 0x56B1
    dw 0x923C, 0x50B6
    dw 0x8D32, 0x4B55
    dw 0x887E, 0x4679
    dw 0x8417, 0x4211
}

